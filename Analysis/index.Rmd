---
title: 'SVG: The Paper'
author: "Alasdair Clarke, Amelia Hunt &  Anna Hughes"
date: "13/04/2022"
output:
  tufte::tufte_html:
    toc: TRUE
    number_sections: true
    fig_height: 4 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
options(digits = 3)
```


```{r, message=FALSE}
# attach packages
library(tidyverse)
library(patchwork)
library(tidybayes)
library(ggrepel)
library(truncnorm)
```


```{r}
# set ggplot2 options
theme_set(ggthemes::theme_tufte() + theme(plot.background = element_rect(fill = "#fffff8", colour = "#fffff8")))

# some more colours
col3 = c("#d04e00", "#ddc000","#34b6c6",  "#79ad41", "#4063a3")
                
our_cols <- c("#1b9e77", "#7570b3")
options(ggplot2.discrete.fill = our_cols ,
        ggplot2.discrete.colour = our_cols)
```

Terminology questions:
- item v target
- participant v observer

# Trial Level Posterior Predictions{#label}

```{r echo = FALSE}
source("functions/get_model_params.R")
source("functions/compute_weights.R")
```

We will start by looking at the visual foraging data from Clarke et al (2022), QJEP. As the current version of our model only takes the $p_A$ bias into account for the initial target selection, we will ignore these data points for now. 

```{r, echo = TRUE}
# read in data
d <- read_csv("data/clarke_2020_qjep.csv", show_col_types = FALSE) %>%
  mutate(condition = as_factor(condition),
         condition = fct_recode(condition, feature = "1", conjunction = "2"),
         targ_type = as_factor(targ_type))

# item weights pre-computed - see scripts/extract_item_weights_using_model.R
a <- readRDS("scratch/qjep_model_weights.rda") %>%
  filter(found != 1) # remove initial selections

# compute the average weight for each participant x condition x item selection
# also compute the proportion of times in which the item selected by the 
# participant was judged the most likely to be selected by our model.
a %>% group_by(condition, observer, found) %>%
  summarise(meanb = mean(b),
            prop_best = mean(selected_max), .groups = "drop") %>%
  # finally, also compute what we would expect under a null-model
  mutate(chance = 1/(41-found))-> a_agg
```

```{r, fig.cap = "(*left*) The average weight assigned to each selected target by our model. (*right*) The proportion of trials the item with the largest assigned weight was selected by the participant.  Each dot shows data from an individual particpant in a condition and the shaded region indicates the interval in which we expect 67% of participants to fall."}

# plot target selected weights
ggplot(a_agg, aes(x = found, y = meanb, colour = condition, fill = condition)) + 
  geom_jitter(data = filter(a_agg, found<40), width = 0.1, height = 0, alpha = 0.2) + 
  stat_lineribbon(.width = 0.67, alpha = 0.50) +
  geom_path(data = filter(a_agg, observer == 1, condition == "feature"), 
                          aes(y = chance), linetype = 2, colour = "black") + 
  geom_point(data = tibble(x=40, y=1), aes(x, y), size = 1.5, colour = "black", fill = "grey") + 
  scale_x_continuous(breaks = c(2, 10, 20, 40), "target selection", expand = c(0.01, 0.01)) + 
  scale_y_continuous("average weight from model", expand = c(0.01, 0.01)) -> plt_b

ggplot(a_agg, aes(x = found, y = prop_best, colour = condition, fill = condition)) + 
  geom_jitter(data = filter(a_agg, found<40), width = 0.1, height = 0.00, alpha = 0.2) + 
  stat_lineribbon(.width = 0.67, alpha = 0.50) +
  geom_path(data = filter(a_agg, observer == 1, condition == "feature"), 
            aes(y = chance), linetype = 2, colour = "black") + 
  geom_point(data = tibble(x=40, y=1), aes(x, y), size = 1.5, colour = "black", fill = "grey") + 
  scale_x_continuous(breaks = c(2, 10, 20, 40), "target selection", expand = c(0.01, 0.01)) + 
  scale_y_continuous("proportion most likely was selected", expand = c(0.01, 0.01)) -> plt_c

plt_b + plt_c + plot_layout(guides = "collect")  &
  theme(legend.position = 'bottom',
        legend.direction = 'horizontal')
ggsave("../Figures/qjep_preds.png", width = 9, height = 4)
```

From this figure we can see a few interesting things to note:

- large individual differences in how well our model can capture and predict behaviour
- feature search is more predictable than conjunction search
- our model appears to be overly conservative

## Calibration

Is our model calibrated? By this we mean, if our model assigns an item a probability $p$ of being selected next, then is it actually selected (by the human participant) this often?

We will calculate this as follows: for each target selection (on each trial, for each participant) we look at the weight assigned to the most likely item, and then look at whether it was selected or not. 


```{r, echo = TRUE}
my_breaks <- seq(0.0, 1, 0.05)

a %>% mutate(b_bin = cut(max_b, breaks = my_breaks, labels = FALSE)) %>%
  group_by(condition, b_bin) %>% 
  summarise(acc = mean(selected_max), .groups = "drop") %>%
  mutate(b_bin = as.numeric(b_bin)/(length(my_breaks)-1)) -> a_cut
```

We can see from the Figure below that our model is well-calibrated (at least in terms of the target with the highest assigned weight). If we repeat this calculation for the 2nd and 3rd ranked candidate items we can see that we slightly underweight these items, but we are still pretty accurate. 

```{r, fig.height=3.5, fig.cap = "(*left*) Calibration plot for our foraging model. The *x*-axis gives the largest weight assigned by the model while the *y*-axis shows how often that target was actually selected by a human participant. (*right*) This plot shows how often the 2nd and 3rd ranked items are selected based on the weights assigned by the model."}

ggplot(a_cut, aes(b_bin, acc, colour = condition, shape = condition)) + 
  geom_point() + 
  geom_line(stat = "smooth", method = "loess", 
            formula = y ~ x, alpha = 0.65, size = 2, se = F) +
  geom_abline(linetype = 2) +
  scale_x_continuous("largest item weight") +
  scale_y_continuous("proportion of times selected") +
  theme(legend.position = "bottom") -> plt1

a %>% select(max_b2, max_b3, selected_max2, selected_max3) %>%
  unite(`2`, max_b2, selected_max2) %>%
  unite(`3`, max_b3, selected_max3) %>%
  pivot_longer(c(`2`, `3`), names_to = "rank", values_to = "b") %>%
  separate(b, into = c("b", "selected"), sep = "_", convert = TRUE) %>%
  mutate(b_bin = cut(b, breaks = my_breaks, labels = FALSE)) %>%
  group_by(b_bin) %>% 
  summarise(acc = mean(selected), .groups = "drop") %>%
   mutate(b_bin = as.numeric(b_bin)/(length(my_breaks)-1)) %>%
  filter(is.finite(acc)) %>%
  ggplot(aes(b_bin, acc)) + 
  geom_point() + 
  geom_line(stat = "smooth", method = "loess", 
            formula = y ~ x, alpha = 0.65, size = 2, se = F) +
  geom_abline(linetype = 2) +
  scale_x_continuous("runner up item weights") +
  scale_y_continuous("proportion of times selected") -> plt2

plt1 + plt2
```

```{r}
rm(a_cut, my_breaks, plt1, plt2)
```

### Individual Differences

How often does each participant select the target with the largest weight? 

```{r, fig.height=3.5, fig.cap = "Prediction scores for participants. Boxplots show quartile range and the grey lines indicate individual participants. (The dots indicate outliers.)", echo= TRUE}

a_agg %>% group_by(observer, condition) %>%
  summarise(accuracy = mean(prop_best), .groups = "drop") -> a_acc

ggplot(a_acc, aes(x= condition, y = accuracy, fill = condition)) + 
  geom_boxplot() +
  geom_line(aes(group = observer), alpha = 0.25, colour = "sienna4") +
  scale_y_continuous("model accuracy",  
                     limits = c(0.3, 0.8), breaks = seq(0.3, 0.8, 0.1))
```

Is this explained by differences in proximity weighting? i.e., are participants with weaker proximity biases harder to predict? Yes! 

```{r, fig.cap = "Accuracy of our model varies with the strength of an individual's model parameters. We can see two clear outlier participants (marked with an X). "}
# computed in xxxx.R
fit <- readRDS("scratch/qjep_model_fit.rda") %>%
  full_join(a_acc, by = c("observer", "condition")) %>%
  mutate(is_outlier = if_else(observer %in% c(35, 45), TRUE, FALSE))


fit_plt <- pivot_longer(fit, c(pA, pS, bP, bM), 
                     names_to = "parameter", values_to = "value") 

ggplot(fit_plt, aes(value, accuracy, colour = condition)) + 
  geom_point(aes(shape = is_outlier)) +
  geom_smooth(data = filter(fit_plt, is_outlier == 0), method = "lm", formula = y ~ x, se = FALSE) + 
  scale_shape_manual(values = c(19, 4), guide = "none") + 
  facet_wrap(~parameter, scales = "free") +
  theme(legend.position = "bottom")
```
As the two outlier participants appear to be doing something different, not captured especially well by our model, we will remove them from the rest of this analysis.

After removing them, we can see that individual differences in proximity tuning account for nearly all of the differences in predictability from person to person, and also between the *feature* and *conjunction* conditions.

```{r, echo = TRUE}
dm <- filter(fit, is_outlier == 0)

summary(lm(accuracy ~ condition * bP, 
           data = dm))


summary(lm(accuracy ~ bP + pS + bM + bP, 
           data = dm))

rm(dm)
```

## Examples of Trials

Let's score every trial by how well the model captures behaviour, and then plot some different examples

```{r, echo = TRUE}
a %>% filter(!(observer %in% c(35, 45))) %>%
  group_by(observer, condition, trial) %>% 
  summarise(prop_max = mean(selected_max), .groups = "drop") %>% 
  arrange(desc(prop_max)) %>%
  ungroup() -> a_trl
```

```{r fig.height=3.5, fig.cap = "Histogram of how predictiable individual trials are, defined as how often the model assigned the largest weight to the target that was then selected."}
ggplot(a_trl, aes(prop_max)) + 
  geom_histogram(fill = "#34b6c6", breaks = seq(0, 1, 0.025)) +
  scale_x_continuous("trial predictability")
```

Let's plot some examples oh highly predictable (top 5%), typical (middle 10%) and unpredictable (bottom 5%) trials.

```{r, echo = TRUE}
qs <- quantile(a_trl$prop_max, c(0.05, 0.40, 0.60, 0.95))

trls_hard <- filter(a_trl, prop_max < qs[1]) %>% sample_n(3)
trls_mid  <- filter(a_trl, prop_max > qs[2], prop_max < qs[3]) %>% sample_n(3)
trls_easy <- filter(a_trl, prop_max > qs[4]) %>% sample_n(3)
```

We can see that for these highly predictable trials, we make very few mistakes, and those that we do make appear to be related to some sort of shortest-path optimization on the part of the participant. 

```{r fig.cap = "A random selection of *good* trials. When participants diverge from the model's prediction, it appears to be due to some form of path-length optimisation."}

source("functions/plot_trial.R")
plts <- map(1:3, plot_trial, trls_easy, a, d)

plts[[1]] + plts[[2]] +
  plot_layout(nrow = 1, widths = c(1,1)) &
   theme(plot.margin = unit(c(.2,.2,.2,.2), "cm")) &
   theme(plot.background = element_rect(color  = "#fffff8", size = 2,linetype = 'dotted', fill ="#fffff8")) &
   theme(text=element_text(size=14,  family="serif"))
```

Here are some typical trials. Possible we have the path-length minimization issue again. 

```{r fig.cap = "A random selection of *typical* trials. Along with path-minimising behaviour, we can also see some disagreement around switching item type."}
plts <- map(1:3, plot_trial, trls_mid, a, d)

plts[[1]] + plts[[2]] +
  plot_layout(nrow = 1, widths = c(1,1)) &
   theme(plot.margin = unit(c(.2,.2,.2,.2), "cm")) &
   theme(plot.background = element_rect(color  = "#fffff8", size = 2,linetype = 'dotted', fill ="#fffff8")) &
   theme(text=element_text(size=14,  family="serif"))
```

Now let's look at less predictable (bottom 5%-tile) trials. Even here, the model does a relatively good job. 

```{r fig.cap = "A random selection of *hard* trials. It is harder to make out much of a pattern here, but we can see that the human participants jump around more."}
plts <- map(1:3, plot_trial, trls_hard, a, d)

plts[[1]] + plts[[2]] +
  plot_layout(nrow = 1, widths = c(1,1)) &
   theme(plot.margin = unit(c(.2,.2,.2,.2), "cm")) &
   theme(plot.background = element_rect(color  = "#fffff8", size = 2,linetype = 'dotted', fill ="#fffff8")) &
   theme(text=element_text(size=14,  family="serif"))
```

```{r}
rm(trls_easy, trls_mid, trls_hard, plts, qs)
```

# Path Length Analysis

It looks like some of the target selections that our model fails to capture are when participants select a further away target in order to minimise overall path length. Here we will compare our model's predicted path length against the empirical paths. 

- We will provide the model/simulation with the initial target selection.

```{r, fig.height=3.5, fig.cap = "(*left*) Histogram comparing the empirical path lengths to simulations from our fitted model. Difference indicates the human path length - the simulated path length. (*right*) Histogram comparing the median path lengths per participant."}
path_lengths <- readRDS("scratch/path_lengths.rda") %>%
  rename(observer = "obs",
         condition = "cond",
         human = "human_path_length",
         model = "model_path_length") %>% 
  mutate(difference  = human - model) %>%
  pivot_longer(c(human, model, difference), names_to = "type", values_to = "path_length")

ggplot(path_lengths, aes(path_length, fill = type)) + 
  geom_histogram(bins = 25, alpha = 0.5, position = "identity") +
  geom_vline(xintercept = 0, linetype = 2) + 
  theme(legend.position = "bottom")  +
  scale_x_continuous("path length")  +
  scale_x_continuous("median path length") +
  scale_fill_manual(values = col3) -> plt1

path_lengths %>% group_by(observer, type) %>%
  summarise(path_length = median(path_length), .groups = "drop") %>%
  ggplot(aes(path_length, fill = type)) + 
  geom_histogram(bins = 25, alpha = 0.5, position = "identity") +
  geom_vline(xintercept = 0, linetype = 2) + 
  theme(legend.position = "bottom") +
  scale_x_continuous("median path length") +
  scale_fill_manual(values = col3) -> plt2

plt1 + plt2 + plot_layout(guides = "collect")  &
  theme(legend.position = 'bottom', legend.title = element_blank())
```

We can see that overall, the model is not making substantially longer paths through the items than our human participants. However, there is some variability in that some participants routinely select paths shorter than our model would, and others do not.

Perhaps this is related to predictability (i.e., how well the model can predict a participant's trial level behaviour)?

```{r fig.height=3, fig.cap = "(*left*) A histogram showing the proportion of trials each participant managed a shorter path through the targets than the model's prediction. (*right*) Scatter plot showing the relationship between predictability (accuracy) and whether the model over or under estimates path length. Xs mark the outlier participants discussed above."}
path_lengths %>% filter(type == "difference") %>%
  mutate(shorter = path_length < 0) %>%
  group_by(observer, condition) %>%
  summarise(prop_shorter = mean(shorter), .groups = "drop") -> path_lengths_obs

path_lengths_obs %>%
  ggplot(aes(prop_shorter, fill = condition)) + 
  geom_histogram(alpha = 0.5, breaks = seq(0, 1, 0.2), position = "identity") +
  scale_x_continuous("prop. shorter than model", breaks = seq(0, 1, 0.2)) -> plt1

path_lengths <- full_join(path_lengths_obs, fit,
                          by = c("observer", "condition"))

ggplot(path_lengths, aes(accuracy, prop_shorter, colour = condition)) + 
  geom_point(aes(shape = is_outlier)) +
  geom_smooth(data = filter(path_lengths, is_outlier == 0), 
              method = "lm", formula = y ~ x, se = FALSE) + 
  scale_shape_manual(values = c(19, 4), guide = "none") + 
  scale_y_continuous("prop. shorter than model", breaks = seq(0, 1, 0.2)) +
  coord_cartesian(ylim = c(0, 1)) -> plt2 

plt1 + plt2 + plot_layout(guides = "collect")  &
  theme(legend.position = 'bottom')
```

```{r}
rm(path_lengths, plt1, plt2)
```

# Initial Selection

Previous work (cite Clarke and Tatler etc) has demonstrated that the initial fixation in scene viewing can be well described with truncated Gaussian distribution. Here we explore using a similar idea to account for starting locations. 

```{r echo = TRUE}
# Reimport data again (as we removed the initial target selection earlier)
d <- read_csv("data/clarke_2020_qjep.csv", show_col_types = FALSE) %>%
  filter(found == 1) %>%
  mutate(condition = as_factor(condition))
```

```{r fig.height = 3.5, fig.cap="(*left*) Density plot for initial target selections, over all participants and all trials. (*right*) Median $x$ and $y$ coordinates for the initial target selection for each participant."}
my_theme <- theme(axis.line=element_blank(),axis.text.x=element_blank(),
          axis.text.y=element_blank(),axis.ticks=element_blank(),
          axis.title.x=element_blank(),
          axis.title.y=element_blank(),legend.position="none",
          panel.background=element_rect(color  = "#808080", size = 2,linetype = 'dotted', fill ="#808080"),
        panel.border= element_rect(colour = "black", fill=NA, size=5),
        panel.grid.major=element_blank(),
        panel.grid.minor=element_blank())

ggplot(d, aes(x, y)) + geom_hex(aes(colour = ..count..), bins = 12) +
  scale_fill_viridis_c() + scale_color_viridis_c() +
  my_theme -> plt_all


d %>% group_by(observer, condition) %>% 
  summarise(x = median(x), y = median(y),
            .groups = "drop") %>%
  ggplot(aes(x, y)) + geom_hex(bins = 12) +
  scale_fill_viridis_c()+ scale_color_viridis_c() +
  my_theme -> plt_med

plt_all + plt_med 

rm(plt_all, plt_med)
```

We can model this as multi-level Gaussian? Yes, although it seems like people are in one of two clusters. 

```{r fig.cap = "The mean posterior plot for the truncated normal distriubtions for (*left*) $x$ and (*right*) $y$. We can see that a two component mixture model will capture most of the variance in intial target selection."}

m <- readRDS("scratch/init_sel_model.rds")
z <- seq(0, 1, 0.01)

gather_draws(m, u[dim, observer]) %>% 
  ungroup() %>%
  select(-.variable) %>%
  rename(obs_b = ".value") %>%
  full_join(gather_draws(m, b[dim]),
             by = c("dim", ".chain", ".iteration", ".draw")) %>%
  mutate(obs_b = .value + obs_b,
         .variable = if_else(dim %in% c(1,2), "mu", "sd"),
         dim = if_else(dim %in% c(1,3), "x", "y")) %>%
  select(observer, dim, .iteration, obs_b, param = ".variable") %>%
  mutate(obs_b = if_else(param == "sd", exp(obs_b), obs_b)) -> a 

a %>% group_by(observer, param, dim) %>%
  summarise(value = mean(obs_b) , .groups = "drop") %>%
  pivot_wider(names_from = param, values_from = value) %>%
  rename(mean = "mu") -> am

create_post_plot <- function(dm) {
  
  pmap(filter(am,  dim == dm) %>% select(mean, sd), dtruncnorm, a = 0, b= 1, x = z) %>%
    set_names(rownames(filter(am,  dim == dm))) %>%
    bind_rows() %>%
    mutate(z = z) %>%
    pivot_longer(-z, names_to = "observer", values_to = "v") %>%
    ggplot(aes(x = z, y = v, group = observer)) + geom_path(alpha = 0.25) +
    scale_x_continuous(dm) + scale_y_continuous("likelihood") -> plt
  
  return(plt)
}

create_post_plot("x") + create_post_plot("y")
```

Do we want to simplify this model to something in which people have some mix of a (fixed) centre and corner bias?




# Item Density

